!
! SuperBayes Package
! 
! by Farhan Feroz (f.feroz@mrao.cam.ac.uk), Roberto Ruiz de Austri (rruiz@ific.uv.es), Pat Scott (patscott@physics.mcgill.ca) and Roberto Trotta (r.trotta@imperial.ac.uk)
!
! This version Dec 2012
!
! This program is based on the GetDist routine of CosmoMC  
! by Anthony Lewis & Sarah Bridle (cosmologist.info/cosmomc)
! modified to allow the computation of new derived observables 
! and to read in param labels from .info file

! RR Aug 2012: the coldata array only loads columns of interest (ie for plotting) in order to make more efficient the analysis and save RAM memory for large arrays
!
! RT May 2009: added caxis limits, cleaned up matlab plots, several small bug fixes, better plots
!              added 1D matlab histogram 
!
! Jan 2008 (RT): improved and expanded plotting options, allows to plot
! marginal posterior
! mean chisquare
! mean likelihood
! profile likelihood
! July 2008 (RT): added furthr plots customization for matlab and SM
! RT: added plotting of likelihood function for selected observables 
!
! RT: all output files are now collected in subfolders in the directory output_files
!
! * file_root.margestats - the mean, limits and stddev from the 1D marginalized distributions
! RT: added Bayesian evidence, mean chi square and best fit, Bayesian complexity
! * file_root.likestats  - the best fit, and limits from the N-D confidence region
! RT: file_root.proflstats - gives 1D profile likelihood confidence intervals  
! * file_root_thin.txt   - thinned merged versions of input files
! * file_root_single.txt - File of weight-1 single samples generated by probabilistic importance sampling
! * file_root.covmat     - covariance matrix for parameters
! * file_root.corr       - covariance matrix for parameters normalized to have unit variance
! * file_root.converge   - Various statistics to help assess chain convergence

! RT: added file_root.burnin.sm - creates a burnin plot for the chains (useful with MCMC)
! RT: added file_root..chain_loc.sm - creates a chain position plot for all the chains (useful with MCMC)

! RT: Data for plots are exported to the plot_data folder
! RT: stats test and other samples manipulations  in module mcsamples.f90
! RT: customize the appearance of matlab plots (2D and scatter 3D) in module matlab.f90
! RT: customize the appearance of SM plots (1D) in module smplots.f90 

! Visit superbayes.org for more info


program GetPlots

        use IniFile
        use MCSamples
        use matlab
        use smplots
        implicit none

        real :: bincounts(-1000:1000),binlikes(-1000:1000),binchisq(-1000:1000),binmaxlike(-1000:1000)
    
        character(LEN=1000) :: InputFile, numstr, InfoFile, numstr1, numstr2
        character(LEN=1000) :: fname
        character(LEN=30000) :: InLine, InLineSM
        real*8 :: invars(max_cols)
        integer :: ix, ix1, i, ix2, ix3, jx, nbins, wx
   
        logical :: bad, adjust_priors

        real :: amax, amin
        character(LEN=1000) :: filename, infile, in_root,out_root, sm_file, matlab_file, chain_file
        character(LEN=1000) :: InS1, InS2
        integer :: chain_ix
       
        integer :: x, y, j, k, j2, num_2D_plots, num_cust2D_plots
        integer :: num_3D_plots
        character(LEN=150) :: plot_3D(20)
        integer :: thin_factor, outliers
        real :: limmin(max_cols),limmax(max_cols)
        integer :: plot_2D_param, j2min
        real :: try_b, try_t, binweight
        real :: dist, distweight, limfrac 
        integer :: bestfit_ix
        integer :: chain_exclude(max_chains), num_exclude
        logical :: map_params
        logical :: all_2D_plots = .false.
        real :: counts
        integer :: tot_plots, failures = 0
   
        real cool
        integer plotparams_num, plotparams(max_cols)
        integer logparams(max_cols)
        logical Done2D(max_cols,max_cols)

        real :: thin_cool
        logical :: no_tests

        real :: var_val, marginal, mean_like, mean_chisq, profile_like
        real :: maxbin_counts, maxbin_like, maxbin_chisq, maxbin_maxlike
        integer :: ios, err

        integer :: ii, cc, ps_max, cutaway

        character(LEN = 25) :: pname
        character(LEN = 400) :: plname, junk(1:3)
        character(LEN = 5) :: lname(2)
        character(LEN = 200) :: HeaderLine

        logical :: NS_files = .false.
        logical :: chain_from_NS 

!---------------------------------------------------------------
!                      Read in options
!--------------------------------------------------------------- 
        InputFile = GetParam(1)
        if (InputFile == '') stop 'No parameter input file'


        !Gets chains filename
        call Ini_Open(InputFile, 1, bad, .false.)
        if (bad) stop 'Error opening parameter file'
        Ini_fail_on_not_found = .true.
        in_root = Ini_Read_String('file_root')
        rootname = ExtractFileName(in_root)
        call Ini_Close
        
        !Opens .info file to read lables from it
        !ncols set automatically
        InfoFile = trim(in_root)//'.info'
        write(*,*) 'Opening .info file: ', trim(InfoFile)
        call OpenFile(Infofile,1,'formatted')
        !gets version of SB with which the chains have been created          
        !to ensure back compatibility  
        read(1,'(a)') HeaderLine

        call Ini_Open(Infofile, 1, bad, .false.)
        if (bad) then
           write(*,*) 'Stop - problem opening file: ', trim(InfoFile)
           stop
        end if
        
        Ncols = Ini_Read_Int('params_saved')
        write(*,*) 'Number of parameters in MCMC chain:' , ncols
        ncols = ncols+2
        do ix=3, ncols
           write (numstr,*) ix-2
           lables(ix) = Ini_Read_String('lab'//trim(adjustl(numstr)), .true.)
        end do

        ebins = 0 
 
        Ini_fail_on_not_found = .false.
        use_log =  Ini_Read_Logical('use_log', .false.)
        use_data =  Ini_Read_Int('use_data')
        action = Ini_Read_Int('action')

        if (action .eq. doPP)  previous_action = Ini_Read_Int('previous_action')
        chain_from_NS = .false.
        if ((action .eq. doNS).or. ((action.eq.doPP).and.(previous_action.eq.doNS)))  then
          chain_from_NS = .true.
        end if

        call Ini_Close

        lables(1) = 'mult'
        lables(2) = 'likelihood'
        Ini_fail_on_not_found = .false.

        !reopens .ini file for rest of parameters
        call Ini_Open(InputFile, 1, bad, .true.)
        if (bad) stop 'Error opening parameter file'
        chain_num = Ini_Read_Int('chain_num')
        nmapped = Ini_Read_Int('add_columns',0)
        !nmapped is the number of extra mapped params you want
        norig = ncols
        ncols = ncols + nmapped
        if (nmapped > 0) then
           write(*,*) 'Warning - adding ', nmapped, ' new params combinations'
           !reads in name of extra params
           do ix=1,nmapped
              write (numstr,*) ix
              lables(norig+ix) = Ini_Read_String('labA'//trim(adjustl(numstr)), .true.)
           end do
        end if

        !PS

        plotparams_num = Ini_Read_Int('plotparams_num',0)
        write(*,*) 'plotparams_num =', plotparams_num
        if (plotparams_num /= 0) then
           InLine = Ini_Read_String_A('plotparams', norig)
           read(InLine,*,end=500) plotparams(1:plotparams_num)
           !InLine = Ini_Read_String_A('logparams', norig)
           !read(InLine,*,end=550) logparams(1:plotparams_num)
        end if

        !sort array from minor to higher
        call sort (plotparams, plotparams_num)
        !call sort (logparams,  plotparams_num)

        !Fix up the labels for all the log parameters
        !forall(i=1:plotparams_num, logparams(i) .ne. 0) lables(plotparams(i)+2) = 'log_{10} [ '//trim(lables(plotparams(i)+2))//' ]'


        if (ncols > max_cols) stop 'Increase max_cols'


        !Only use variables whose lable's are not empty (and in list of plotparams if plotparams_num /= 0)
        colix(1) = 1
        colix(2) = 2 
        num_vars = 2
        do ix = 3,ncols
            if (lables(ix) /= '') then
              if (plotparams_num == 0 .or. any(plotparams(1:plotparams_num)==ix-2)) then
                 num_vars = num_vars + 1
                 colix(num_vars) = ix
              end if
           end if
        end do
        ncols_eff =  num_vars
        !print*,'ncols_eff ',ncols_eff, num_vars

        write(*,*) 'Allocation of arrays...'
        allocate(coldata(1:num_vars,0:max_rows))

        allocate(inputdata(1:num_input+2,0:max_rows))

        ps_max = 2*max_rows-1
        !allocate(PowerSpectrum(ncols,0:ps_max)) !double as many rows as it needs to store complex numbers.

        !if you want 1 or 2 tails confidence limits
        do ix=3, ncols
           if (ix <= norig) then
              write (numstr,*) ix-2
              InLine = Ini_Read_String('tails'//trim(adjustl(numstr)), .false.)
           else
              write (numstr,*) ix-norig
              InLine = Ini_Read_String('tailsA'//trim(adjustl(numstr)), .false.)
           end if
           if (InLine /= '') then
              read (InLine,*) tails(ix) 
           end if
        end do

        nbins = Ini_Read_Int('num_bins')
        skip_bin = Ini_Read_Int('skip_bin', 0)
        ignorerows = Ini_Read_Int('ignore_rows',0)
        adjust_priors = Ini_Read_Logical('adjust_priors',.false.)

        all_2D_plots = Ini_Read_Logical('all_2D_plots',.false.)
        plot_2D_meanlike = Ini_Read_Logical('plot_2D_meanlike', .false.)
        plot_2D_meanchisq = Ini_Read_Logical('plot_2D_meanchisq', .false.)

        no_tests = Ini_Read_Logical('no_tests',.false.)

        thin_factor = Ini_Read_Int('thin_factor',0)
        thin_cool = Ini_read_Real('thin_cool',1.)

        first_chain = Ini_Read_Int('first_chain',1)

        make_single_samples = Ini_Read_logical('do_3D_plots',.false.)
        single_thin = Ini_Read_Int('single_thin',1)
        cool = Ini_Read_Real('cool',1.)

        Num_ComparePlots = Ini_Read_Int('compare_num',0)
        together = Ini_Read_Logical('plot_together')
        colorbar_on = Ini_Read_Logical('colorbar_on')
        single_colorbar_on = (colorbar_on .and. .not. together)
        plot_contours = Ini_Read_Logical('plot_contours')
        plot_mean = Ini_Read_Logical('plot_mean')
        plot_bestfit = Ini_Read_Logical('plot_bestfit')
        !if you want to plot a reference point (as defined in 
        plot_reference = Ini_Read_Logical('plot_reference')
        othercomments = Ini_Read_String('comments')
        credit = Ini_Read_String('credit')

        plot_1D_pdf = Ini_Read_Logical('plot_1D_pdf')       
        plot_1D_meanlike = Ini_Read_Logical('plot_1D_meanlike')       
        plot_1D_meanchisq = Ini_Read_Logical('plot_1D_meanchisq')       
        plot_1D_profile = Ini_Read_Logical('plot_1D_profile')       
        plot_1D_likelihood = Ini_Read_Logical('plot_1D_likelihood') 

        color_scheme = Ini_Read_Int('color_scheme',2)
        
        !some new 3D options
        caxis_min = Ini_Read_Real('caxis_min', 0.0)
        caxis_max = Ini_Read_Real('caxis_max', 0.0)
        plot_3D_psname = ''
        plot_3D_psname = Ini_Read_String('plot_3D_psname', .false.)
        if (trim(plot_3D_psname) .ne. '') write(*,*) 'Saving 3D files as: ', trim(plot_3D_psname)

        do ix = 1, Num_ComparePlots
           ComparePlots(ix) = &
             ExtractFileName(Ini_Read_String(numcat('compare',ix), .true.))
        end do

        has_limits_top = .false.
        has_limits_bot = .false.

        !limits (to map all samples outside the limits to the min/max bin)
        do ix=3, ncols
           if (ix <= norig+2) then
              write (numstr,*) ix-2
              InLine = Ini_Read_String('limits'//trim(adjustl(numstr)))
           else
              write (numstr,*) ix-norig
              InLine = Ini_Read_String('limitsA'//trim(adjustl(numstr)))
           end if
           if (InLine /= '') then
              read (InLine,*) InS1, InS2 
              if (trim(adjustl(InS1)) /= 'N') then
               has_limits_bot(ix) = .true.
               read(InS1,*) limmin(ix)
              end if
              if (trim(adjustl(InS2)) /= 'N') then
                has_limits_top(ix) = .true.
                read(InS2,*) limmax(ix)
              end if
           end if
        end do
        !plot_limits (purely for plotting, sets axis limits)
        InLineSM = ''
        do ix=3, ncols
           if (ix <= norig+2) then
              write (numstr,*) ix-2
              InLineSM = Ini_Read_String('plot_limits'//trim(adjustl(numstr)))
              has_plot_limits(ix) = .false.
             ! write(*,*) 'Looking for SM', trim(numstr)
           end if
           if (InLineSM /= '') then
              !write(*,*) 'FOUND'
              read (InLineSM,*) InS1, InS2 
              has_plot_limits(ix) = .true.
              read(InS1,*) plot_limits_min(ix)
              read(InS2,*) plot_limits_max(ix)              
           end if
        end do

        has_limits = has_limits_top .or. has_limits_bot

        plot_2D_param = Ini_Read_Int('plot_2D_param',0)
        if (plot_2D_param /= 0) then
           plot_2D_param = plot_2D_param + 2
           num_cust2D_plots = 0
        else
           !Use custom array of specific plots
           num_cust2D_plots = Ini_Read_Int('plot_2D_num',0)
           do ix = 1, num_cust2D_plots
              InLine = Ini_Read_String_A(numcat('plot',ix), norig, .true.)
              read (InLine, *) ix1,ix2
              cust2Dplots(ix) = ix1+2 + (ix2+2)*1000 
           end do
        end if

        InS1 =Ini_Read_String('exclude_chain')
        num_exclude = 0
        chain_exclude = 0
        read (InS1, *, end =20) chain_exclude
        
20      do while (chain_exclude(num_exclude+1)/=0) 
           num_exclude = num_exclude + 1
        end do

        map_params = Ini_Read_Logical('map_params',.false.)
        if (map_params) write (*,*) 'WARNING: Mapping params - .covmat file is new params.'

        smoothing = Ini_Read_Logical('smoothing',.true.)

        out_root = Ini_Read_String('out_root')

        if (out_root /= '') then
           rootname = trim(out_root)//'/'//trim(out_root)
        else
           out_root = rootname 
           rootname = trim(rootname)//'/'//trim(rootname)
        end if

        write (*,*) 'producing files with root '//trim(rootname)
        call CreateDirectory('../output_files/'//trim(out_root),err)
        call CreateDirectory('../plot_data/'//trim(out_root),err)

        contours(1) = Ini_Read_Real('contour1',0.)
        contours(2) = Ini_Read_Real('contour2',0.)
        contours(3) = Ini_Read_Real('contour3',0.)

        num_contours = count(contours/= 0)

        if (contours(1)==0) contours(1) = contours(2)

        force_twotail = Ini_Read_Logical('force_twotail',.false.)  
        if (force_twotail) then
           write (*,*) 'Computing two tail limits'
           tails(:) = 2
        end if
        
        covmat_dimension = Ini_Read_Int('cov_matrix_dimension',0)

        plot_NDcontours = Ini_Read_Logical('plot_NDcontours',.false.)

        num_3D_plots = Ini_Read_Int('num_3D_plots',0)
        do ix =1, num_3D_plots
           plot_3D(ix) = Ini_Read_String_A(numcat('3D_plot',ix), norig, .true.)
        end do
        if (num_3D_plots > 0) make_single_samples = .true. 

        do_shading = Ini_Read_Logical('do_shading',.true.)

        colormap_name = 'jet' !this is the default
        colormap_name = Ini_Read_String('colormap_name', .false.)
        
        call Ini_Close 


!---------------------------------------------------------------
!                      Read in input chains
!--------------------------------------------------------------- 
    
        !allocation
        allocate(bins2D(-1000:1000,-1000:1000), &
                 bin2Dlikes(-1000:1000,-1000:1000), &
                 bin2Dchisq(-1000:1000,-1000:1000), &
                 bin2Dmax(-1000:1000,-1000:1000), &
                 bin2D_NDmax(-1000:1000,-1000:1000))
 
       
        !Read in the chains     
        nrows = 0
        num_chains_used =0


        do chain_ix = first_chain, first_chain-1 + max(1,chain_num)

           do ix = 1, num_exclude
              if (chain_exclude(ix) == chain_ix) exit
           end do
      
           if (chain_num == 0) then
              infile = trim(in_root)
           else
              write (numstr,*) chain_ix
              infile = trim(in_root) //'_'//trim(adjustl(numstr))
           end if

           write (*,*) 'Trying to read ' // trim(infile)//'.txt'
           failures = 0
           ios = 0
           open(unit=50,file=trim(infile)//'.txt',form='formatted',status='old', iostat=ios)
           if (ios .ne. 0) then
              !try chain from NS run, old format 
              write(*,*) 'Chain not found!'
              write(*,*) 'Now trying to read ' // trim(infile)//'post.dat'
              open(unit=50,file=trim(infile)//'post.dat',form='formatted',status='old', err=18)
              NS_files = .true.
           end if

           write(*,*) 'Chain found, please wait...'

           do ix = 1, ignorerows*(ebins+1)
              read (50,'(a)',end=1) InLine
           end do

           num_chains_used = num_chains_used + 1
           if (num_chains_used > max_chains) stop 'Increase max_chains in GetDist'
           chain_indices(num_chains_used) = nrows
           chain_numbers(num_chains_used) = chain_ix
           do
              read (50,'(a)',end=1) InLine
              read(InLine,*,end=1,err=2) invars(1:ncols-nmapped)
              
              !write(*,*) 'here:', invars(1), highprec(1)
              !need to reconvert alpha_EM (RT: this is for chains produced with SB versions older than SB v1.23)
              !the workaround below only works for v1.23 chains

              if (map_params) call MapParameters(invars)
              if (nmapped > 0) call AddParameters(invars)

              ! Convert all variables where logparams is nonzero to log values
              !forall(i=1:plotparams_num, logparams(i) .ne. 0) invars(plotparams(i)+2) = log10(invars(plotparams(i)+2))

              do i = 1, num_vars
                coldata(i,nrows) = invars(colix(i)) 
              enddo

              inputdata(1:num_input+2, nrows) = invars(1:num_input+2)

              if (adjust_priors) call AdjustPriors(invars, cutaway)

              !RT NEW: this fixes a previous bug affecting the Profile Likelihood 
              !NS chains save in position 2 the quantity: -2ln(like) = chi-square 
              !MCMC chains save in position 2 the quantity: -ln(like) = chi-square/2
              !GetPlots assumes that the 2nd column contains -ln(like), hence we need to adjust the value 
              !output by NS by dividing it by a factor of 2
              if (chain_from_NS) then
                 coldata(2, nrows) = coldata(2,nrows)/2.0
                 inputdata(2, nrows) = inputdata(2,nrows)/2.0
              endif
              nrows = nrows + 1
              if (nrows > max_rows) stop 'need to increase max_rows'

           end do
2          write (*,*) 'error reading line ', nrows + ignorerows, ' - trying to continue...'
           write(*,*) 'Offending line ', trim(InLine)
           failures = failures+1
           nrows = nrows + 1
           if (failures<max_failures) then
              cycle
           else
              write(*,*) 'Too many errors, skipping the rest of the file'   
           end if
1          close(50)
           cycle
18         write (*,'(" chain ",1I4," missing")') chain_ix
       end do

        if (adjust_priors) write(*,*) 'AdjustPrior: cutpoints = ', cutaway, ', percent of total', 1.0*cutaway/(1.0*nrows)  

        if (nrows == 0) stop 'No un-ignored rows!'

        if (cool /= 1) call CoolChain(cool)

        call GetUsedCols !See which parameters are fixed
       
!---------------------------------------------------------------
!                      Elaborate samples
!--------------------------------------------------------------- 


        mean_mult = sum(coldata(1,0:nrows-1))/nrows
        max_mult = (mean_mult*nrows)/min(nrows/2,500)
        outliers = count(coldata(1,0:nrows-1) > max_mult)
        if (outliers /=0) write (*,*) 'outlier fraction ', real(outliers)/nrows
        
        maxmult = maxval(coldata(1,0:nrows-1))
        numsamp = sum(coldata(1,0:nrows-1))
        
        if (.not. no_tests) then
           call DoConvergeTests
           !----------------------------------------------------
           !          Power spectrum 
           !---------------------------------------------------- 
           !call ComputePowerSpectrum 
        end if
        if (adjust_priors) call DeleteZeros  
        write (*,*) 'mean input multiplicity = ',mean_mult
        
        !Output thinned data if requested
        !Must do this with unsorted output  
        if (thin_factor /= 0) then 
           call ThinData(thin_factor)
           call WriteThinData(trim(outn)//trim(rootname)//'_thin.txt',thin_cool)
        end if
        
        !Produce file of weight-1 samples if requested
        if (make_single_samples) then
           single_thin = max(1,nint(numsamp/maxmult)/2000)
           write(*,*) 'Thinning factor for uniformly weighted samples = ', single_thin
           write(*,*) 'Numsamp,maxmult, factor', numsamp, maxmult, nint(numsamp/maxmult)/2000 
        end if
        if (make_single_samples) call MakeSingleSamples(single_thin)
        
        !Sort data in order of likelihood of points
        call SortColData(2)
        numsamp = sum(coldata(1,0:nrows-1))
       
        !Get ND confidence region (index into sorted coldata)
        counts = 0
        ND_cont1=-1; ND_cont2=-1
        do j=0, nrows -1
           counts = counts + coldata(1,j)
           if (counts > numsamp*contours(1) .and. ND_cont1==-1) then
              ND_cont1 = j
              if (ND_cont2 /= -1) exit
           end if
           if (counts > numsamp*contours(2) .and. ND_cont2==-1) then
              ND_cont2 = j
           end if
        end do
        


       !Only use variables whose lable's are not empty (and in list of plotparams if plotparams_num /= 0)
        colix = 0
        num_vars = 0
        jx = 0
        do ix = 3,ncols_eff
           jx = jx + 1
           if (lables(ix) /= '' .and. isused(ix)) then
                 num_vars = num_vars + 1
                 colix(num_vars) = plotparams(jx)+2
                 mean(num_vars) = sum(coldata(1,0:nrows-1)*coldata(ix,0:nrows-1))/numsamp
                 sddev(num_vars)  = sqrt(sum(coldata(1,0:nrows-1)*(coldata(ix,0:nrows-1) &
                      -mean(num_vars))**2)/numsamp)
           end if
        end do
        

        all_2D_plots = all_2D_plots .and. (num_vars > 1)
        write (*,*) 'using ',nrows,' rows, processing ',num_vars,' parameters'
        write(*,*) 'All 2D plots status = ', all_2D_plots
        if (indep_thin/=0) then
           write (*,*) 'Approx indep samples: ', nint(numsamp/indep_thin)
        else
           write (*,*) 'effective number of samples (assuming indep): ', nint(numsamp/maxmult)
        end if
        !Get covariance matrix and correlation matrix
        call GetCovMatrix
        
        !Find best fit, and mean likelihood     
        bestfit_ix = 0 !Since we have sorted the lines
        maxlike = coldata(2,bestfit_ix)
        write (*,'(A, F10.5)')    'Best fit -Ln(like)              = ', maxlike
        
        if (coldata(2,nrows-1) - maxlike < 30) then
           meaninvlike = log(sum(exp((coldata(2,0:nrows-1) -maxlike))*coldata(1,0:nrows-1)) & 
                / numsamp) + maxlike
           write (*,'(A, F10.5)') 'Ln(mean 1/like)                 = ', meaninvlike
        end if
        
        meanchisq = sum(coldata(2,0:nrows-1)*coldata(1,0:nrows-1)) / numsamp 
        write (*,'(A, F10.5)')    'Mean(-Ln(like)) = mean(chisq/2) = ', meanchisq
        
        meanlike = -log(sum(exp(-(coldata(2,0:nrows-1) -maxlike))*coldata(1,0:nrows-1)) & 
             / numsamp) + maxlike
           write (*,'(A, F10.5)') '-Ln(mean like)                  = ', meanlike
        

!------------------------------------------------------------
!                        SM 1D plotting file Init
!------------------------------------------------------------

        !Output files for 1D plots
        plot_col =  nint(sqrt(num_vars/1.4))
        plot_row = (num_vars +plot_col-1)/plot_col 
        !So we don't forget to run sm, delete current .ps file
        !call DeleteFile(trim(rootname)//'.ps')        

        !Initializes SM file for 1D plots
        sm_file = trim(outn)//trim(rootname) // '_1D.sm'
        open(unit=50,file=sm_file,form='formatted',status='replace')
        call WriteSM1DPlotInit(50, '_1D' )
        !Initializes Matlab file for 1D plots
        matlab_file = trim(outn)//trim(rootname) // '_1D.m'
        open(unit=60,file=matlab_file,form='formatted',status='replace')
        call WriteMatLabInit(60, 1)
 

!------------------------------------------------------------
!                          Do 1D bins
!------------------------------------------------------------
        write(*,'(A,I6,A,I6)') 'Total number of variables = ', ncols_eff, ' Used variables =', num_vars

        cont_lines = 0
        plot_num = 0 
        do j = 1,num_vars
           ix = colix(j)
           write(*,'(A,I4,A,I4,A,I2,2A)') 'Now doing 1D var j=', j, &
           ' ix = ', ix,  ' tails = ', tails(ix),  ' name = ', trim(lables(ix))
           bincounts = 0
           binlikes = 0
           binchisq = 0
           binmaxlike = 1e30
           do ix1 = 1, num_contours
              limfrac = (1-contours(ix1)) !1-tail 
              if (tails(ix) .eq. 2) then
                 limfrac = limfrac/2 !2-tails 
              end if
              !1D marginal post intervals
              cont_lines(j,2,ix1) = ConfidVal(j+2,limfrac,.true.)
              cont_lines(j,1,ix1) = ConfidVal(j+2,limfrac,.false.)
              !1D frequentist delta ln like 
              profl_cont(ix1) = exp(-GetDeltaChiSquare(contours(ix1), 1.0)/2.0)
           end do 
           if (has_limits_bot(ix)) then
              amin = limmin(ix)
           else
              amin = ConfidVal(j+2,0.0001,.false.)
           end if
           if (has_limits_top(ix)) then
              amax = limmax(ix)
           else
              amax = ConfidVal(j+2,0.0001,.true.)
           end if

           width(j) = (amax-amin)/(nbins+1)

           !write(*,*) 'widht ', amax, amin, j, width(j)
           if (width(j)==0) cycle
           if (amin <= 0) then 
              center(j) = amax
           else
              center(j) = amin
           end if
           !write(*,*) 'width = ', width(j), ' amax = ', amax, ' amin= ', amin, ' center= ', center(j) !RT
           ix_min(j) = nint((amin - center(j))/width(j))
           ix_max(j) = nint((amax - center(j))/width(j))

           if (smoothing  .and. amin > 0) ix_min(j) = ix_min(j)-1
           if (smoothing) ix_max(j) = ix_max(j)+1

           do i = 0, nrows-1
              ix2=nint((coldata(j+2,i)-center(j))/width(j))
              !puts all points above limits into upper bin
              if (ix2 > ix_max(j)) ix2 = ix_max(j)
              !correspondingly for points below lower limit 
              if (ix2 < ix_min(j)) ix2 = ix_min(j)
              if (smoothing .and. ix_min(j) /= ix_max(j)) then
                 do wx = max(ix_min(j),ix2-2),min(ix_max(j),ix2+2)
                    !dist = coldata(colix(j),i) - (center(j) + wx*width(j))
                    dist = coldata(j+2,i) - (center(j) + wx*width(j)) 
                    distweight = exp(- dist**2/width(j)**2/2)
                    binweight = coldata(1,i)*distweight
                    !posterior pdf
                    bincounts(wx) = bincounts(wx)  + binweight
                    !mean like
                    binlikes(wx) = binlikes(wx) + binweight*exp(-coldata(2,i))
                    !mean chisquare
                    binchisq(wx) = binchisq(wx) + binweight*coldata(2,i)
                 end do
              else
                 !un-smoothed bins
                 !posterior pdf
                 bincounts(ix2) = bincounts(ix2) + coldata(1,i)
                 !this gives for the meanlike: (mean(like) in bin)/mean(like) in all sample
                 !binlikes(ix2) = binlikes(ix2) + coldata(1,i)*exp(meanlike-coldata(2,i))
                 !we take out the whole sample mean:
                 binlikes(ix2) = binlikes(ix2) + coldata(1,i)*exp(-coldata(2,i))
                 !here we average over the chisquare instead
                 binchisq(ix2) = binchisq(ix2) + coldata(1,i)*coldata(2,i)
              end if
              !profile like (here, the min chisq)
              binmaxlike(ix2) = min(binmaxlike(ix2), real(coldata(2,i)))
           end do
           
           do i=ix_min(j),ix_max(j)
              if (bincounts(i) >0) then
                 !mean like over points in the bin
                 binlikes(i) = binlikes(i)/bincounts(i)
                 !average chisq - bestfit chisq
                 binchisq(i) = binchisq(i)/bincounts(i)- coldata(2,0)
                 !max like - overall like max
                 binmaxlike(i) = exp(-(binmaxlike(i)- coldata(2,0)))
              else
                 binmaxlike(i) = 0d0
              end if
           end do
           
           !Frequentist intervals
           do cc=1,num_contours
              int_num(j,cc) = 0
              if (binmaxlike(ix_min(j)) > profl_cont(cc)) then
                 !PS bug fix Jun 27 2011 - swapped the following two lines
                 int_num(j,cc) = 1
                 profl_interval(j, 1, int_num(j,cc),cc) =  center(j) + (ix_min(j)+0.5)*width(j)
              end if
              do i=ix_min(j),ix_max(j)-1
                 !variable value
                 var_val =  center(j) + (i+0.5)*width(j)
                 !write(*,*) 'bin = ', i, '(binmaxlike(i)-profl_cont(1) ', binmaxlike(i), binmaxlike(i+1) 
                 if ((binmaxlike(i)>profl_cont(cc)) .and. (binmaxlike(i+1)<profl_cont(cc))) then
                    profl_interval(j, 2, int_num(j,cc),cc) = var_val
                    !end of an interval
                    !write(*,*) 'END!'
                 else if ((binmaxlike(i)<profl_cont(cc)) .and. (binmaxlike(i+1)>profl_cont(cc))) then
                    !start of a new interval
                    !write(*,*) 'START!'
                    int_num(j,cc) = int_num(j,cc)+1
                    if (int_num(j,cc) > max_intervals) then
                       write(*,*) 'Max_num_cont exceeded for variable: ', j, '(value = ', int_num(j,cc), ')'
                       stop
                    end if
                    profl_interval(j, 1, int_num(j,cc), cc) = var_val
                 end if
              end do
              if (profl_interval(j, 2, int_num(j,cc),cc) .eq. 0.0) profl_interval(j, 2, int_num(j,cc),cc) = &
                   center(j) + (ix_max(j)+0.5)*width(j)
              if (profl_interval(j, 1, int_num(j,cc),cc) .eq. 0.0) profl_interval(j, 1, int_num(j,cc),cc) = &
                   center(j) + (ix_min(j)+0.5)*width(j)
           end do


           !----------------------------------------------------
           !          1D data files for plotting
           !---------------------------------------------------- 
           fname =trim(trim(rootname)//trim(numcat('_p',colix(j)-2)))
           filename = '../plot_data/'// trim(fname)
           open(unit=49,file=trim(filename)//'.dat',form='formatted',status='replace')
           write(*,*) 'Opening for writing: ', trim(filename)
           if (.not. normalize_1D) then
              maxbin_counts = 1.d0
              maxbin_like = 1.d0
              maxbin_chisq = 1.d0
              maxbin_maxlike = 1.d0
           else
              maxbin_counts = maxval(bincounts(ix_min(j)+skip_bin:ix_max(j)-skip_bin))
              maxbin_like = maxval(binlikes(ix_min(j)+skip_bin:ix_max(j)-skip_bin))
              !maxbin_chisq = maxval(binchisq(ix_min(j)+skip_bin:ix_max(j)-skip_bin))
              maxbin_chisq = 1.d0
              !better leave it unnormalized
           end if
           !format is: variable value, pdf, mean like, mean chisq, profile like
           do i = ix_min(j)+skip_bin, ix_max(j)-skip_bin
              !variable value
              var_val =  center(j) + (i+0.5)*width(j)
              !marginal pdf
              marginal =  bincounts(i)/maxbin_counts
              !mean like
              mean_like =  binlikes(i)/maxbin_like
              !mean chisq
              mean_chisq = binchisq(i)/maxbin_chisq
              !profile like
              profile_like = binmaxlike(i) !already normalized to max like value 
              write (49,'(5E20.9)') var_val, marginal, mean_like, mean_chisq, profile_like
           end do
           if (ix_min(j) == ix_max(j)) write (49,'(1E15.5,'' 0'')') center(j) + ix_min*width(j)
           close(49)

           !----------------------------------------------------
           !SM 1D plot file
           !----------------------------------------------------
           plot_x = mod(j+plot_col-1,plot_col)+1
           plot_y = plot_row - (j+plot_col-1)/plot_col + 1 

           call Write1DPlotSM(50, trim(filename), j)
           plot_num = plot_num+1
           call Write1DPlotMatlab(60, trim(rootname),j)

        end do !loop over variables to plot
        call FinalTouches1DPlotSM(50)
        if (together) then
           call FinalTouchesMatlab(60,-10)
           write (60,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_1D.ps;'
        end if
        close(50)
        close(60)
          

        !----------------------------------------------------
        !Power spectrum 
        !----------------------------------------------------
        !Initializes SM
        chain_file = trim(outn)//trim(rootname) // '.power.sm'
        open(unit=60,file=chain_file,form='formatted',status='replace')
        write (60,'(A)') 'device postfile ../'//trim(rootname)//'.power.ps'
        call WriteSMChainsInit(60, '.power')

        close(60)


        !----------------------------------------------------
        !chains positions files
        !----------------------------------------------------
        !Initializes SM file for chain location
        chain_file = trim(outn)//trim(rootname) // '.chain_loc.sm'
        open(unit=60,file=chain_file,form='formatted',status='replace')
        call WriteSMChainsInit(60, '.chain_loc')
        call WriteSMLoadChains(60, trim(in_root))
        do chain_ix = 1, num_chains_used
           write(numstr,*) chain_numbers(chain_ix)
           write (60,'(A)') 'device postfile ../'//trim(rootname)//'.chain_loc'//trim(adjustl(numstr))//'.ps'
           do j = 1,num_vars
              plot_x = mod(j+plot_col-1,plot_col)+1
              plot_y = plot_row - (j+plot_col-1)/plot_col + 1 
              call ChainPositionPlot(60,  chain_numbers(chain_ix), j)
           end do
           call FinalTouchesChainPlot(60,chain_numbers(chain_ix))
        end do
        close(60)

        !----------------------------------------------------
        !Chi-square evolution (burn in assessment)
        !----------------------------------------------------
        !Initializes SM
        chain_file = trim(outn)//trim(rootname) // '.burnin.sm'
        open(unit=60,file=chain_file,form='formatted',status='replace')
        write (60,'(A)') 'device postfile ../'//trim(rootname)//'.burnin.ps'
        call WriteSMChainsInit(60, '.burnin')
        call WriteSMLoadChains(60, trim(in_root))
        plot_col =  nint(sqrt(num_chains_used/1.4))
        plot_row = (num_chains_used +plot_col-1)/plot_col  
        do chain_ix = 1, num_chains_used
           plot_x = mod(chain_ix+plot_col-1,plot_col)+1
           plot_y = plot_row - (chain_ix+plot_col-1)/plot_col + 1 
           call BurnInPlot(60,  chain_numbers(chain_ix))
        end do
        call FinalTouchesBurnInPlot(60)
        close(60)


!------------------------------------------------------------------------------------
                                    !Do 2D bins
!------------------------------------------------------------------------------------

          if (plot_2D_param == 0 .and. num_cust2D_plots==0) then
             !In this case output the most correlated variable combinations
             write (*,*) 'doing 2D plots for most correlated variables'
             try_t = 1e5
             x=0;y=0;  
             num_cust2D_plots = 12
              do j = 1, num_cust2D_plots
               try_b = -1e5
               do ix1 =1 ,num_vars
                do ix2 = ix1+1,num_vars 
                   if (abs(corrmatrix(colix(ix1)-2,colix(ix2)-2)) < try_t .and. &
                        abs(corrmatrix(colix(ix1)-2,colix(ix2)-2)) > try_b) then
                      try_b = abs(corrmatrix(colix(ix1)-2,colix(ix2)-2))
                      x = ix1; y = ix2;
                    end if
                end do
               end do
               if (try_b == -1e5) then
                  num_cust2D_plots = j-1
                  exit
               end if
               try_t = try_b

             cust2Dplots(j) = colix(x) + colix(y)*1000
             end do
          end if !most correlated

          !no custom 2D plots specified, ie plot_2D_num == 0
          if (num_cust2D_plots == 0) then
             num_2D_plots = 0
             !does 2D plots for all variables with labels and not are not fixed
             do j= 1, num_vars
                if (ix_min(j) /= ix_max(j)) then
                   do j2 = j+1, num_vars
                      if (ix_min(j2) /= ix_max(j2)) then
                         if (plot_2D_param==0 .or. plot_2D_param == colix(j) .or. plot_2D_param == colix(j2)) &
                              num_2D_plots = num_2D_plots + 1
                      end if
                   end do
                end if
             end do
          else
             num_2D_plots = num_cust2D_plots
          end if
          done2D= .false.


          if (num_2D_plots > 0) then
             write (*,*) 'Producing ',num_2D_plots,' 2D plots'
             !---------------------------------------------
             !Matlab 2D file
             !--------------------------------------------
             filename = trim(outn)//trim(rootname)//'_2D.m'
             open(unit=50,file=filename,form='formatted',status='replace')
             !here all the header stuff you might need
             plot_col = nint(sqrt(num_2D_plots/1.4))
             plot_row = (num_2D_plots +plot_col-1)/plot_col 
             call WriteMatLabInit(50, 2)
             plot_num = 0        
             do j= 1, num_vars
                if (ix_min(j) /= ix_max(j)) then
                   if (plot_2D_param/=0 .or. num_cust2D_plots /= 0) then
                       !looks for the corresponding column in file
                      if (colix(j) == plot_2D_param) cycle
                      j2min = 1
                   else
                      j2min = j+1
                   end if
                   do j2 = j2min, num_vars
                      if (ix_min(j2) /= ix_max(j2)) then
                         !write(*,*) 'some info for you'
                         !write(*,*) 'cust2Dplots = ', cust2Dplots(1:num_cust2D_plots)
                         !write(*,*) 'second bit = ',  colix(j)*1000 + colix(j2)
                         !countres = count(cust2Dplots(1:num_cust2D_plots) == colix(j)*1000 + colix(j2))
                         if (plot_2D_param/=0 .and. colix(j2) /= plot_2D_param) cycle
                         if (num_cust2D_plots /= 0 .and.  &
                              !the line below returns .false. if this is the plot you want
                              count(cust2Dplots(1:num_cust2D_plots) == colix(j)*1000 + colix(j2))==0) cycle
                         plot_num = plot_num + 1
                         write(*,'(A,I4,A,3A)') 'Doing 2D plot', plot_num, &
                            ' for params ', trim(lables(colix(j))), &
                            ' vs ', trim(lables(colix(j2)))
                         done2D(j,j2) = .true.
                         call Get2DPlotData(j,j2)

                         !marginal distribution
                         call Write2DPlotMATLAB(50,j,j2,ShadeMargProb)
                         if (.not.together) call FinalTouches_SingleFig_MATLAB(50, '_2D_marg_'//trim(IntToStr(plot_num)))
                         !mean likelihood
                         if (plot_2D_meanlike) then
                            !the mean like and the mean chi-square, as well 
                            call Write2DPlotMATLAB(50,j,j2,ShadeMeanLike)
                            if (.not.together) call FinalTouches_SingleFig_MATLAB(50, '_2D_like_'//trim(IntToStr(plot_num)))
                         end if
                         if (plot_2D_meanchisq) then
                            !mean chi square
                            call Write2DPlotMATLAB(50,j,j2,ShadeMeanChisq)
                            if (.not.together) call FinalTouches_SingleFig_MATLAB(50, '_2D_chisq_'//trim(IntToStr(plot_num)))
                         end if
                         !profile like
                         call Write2DPlotMATLAB(50,j,j2,ShadeProfLike)
                         if (.not.together) call FinalTouches_SingleFig_MATLAB(50, '_2D_profl_'//trim(IntToStr(plot_num)))
                         !single samples 2D scatter plot
                         call Write2DPlotMATLAB(50,j,j2,SingleSamples)
                         if (.not.together) call FinalTouches_SingleFig_MATLAB(50, '_2D_single_'//trim(IntToStr(plot_num)))

                      end if
                   end do
                end if
             end do

             if (together) then
                call FinalTouchesMATLAB(50,ShadeMargProb)
                write (50,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_2D_marg.ps;'
                !uncomment
                !call FinalTouchesMATLAB(50, ShadeMeanLike)
                !write (50,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_2D_like.ps;'
                !uncomment 
                !call FinalTouchesMATLAB(50,ShadeMeanChisq)
                !write (50,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_2D_chisq.ps;'
                call FinalTouchesMATLAB(50,ShadeProfLike)
                write (50,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_2D_profl.ps;'
                call FinalTouchesMATLAB(50,SingleSamples)
                write (50,'(A)') 'print -dpsc2 ../../'//trim(outn)//trim(rootname)//'_2D_single.ps;'
             end if
             if (plot_num < num_cust2D_plots) then
                write(*,'(A,I4,A)') &
                'WARNING - you have requested', num_cust2D_plots, ' 2D plot(s) '
                write(*,'(A,I4,A)') &
                '          but only', plot_num, ' have been produced'
                write(*,'(A)') &
                '          You might want to check your choice for plotparams. &
                &  Notice that the parameters you want to plot in 2D have to be included in plotparams'
             end if
              
             close(50)

          end if !num_2D_plots > 0

!------------------------------------------------------------------------------------
                                    !Do ALL 2D plots (all_2D_plots = T)
!------------------------------------------------------------------------------------
          if (all_2D_plots) then
             plot_num = 0
             tot_plots = (num_vars**2)/2-num_vars
             do j2 = 1, num_vars
                do j = j2+1, num_vars                
                   !invert axis x <-> y 
                   plot_num = plot_num+1
                   if (mod(plot_num, 100) == 0) write(*,*) 'Done 2D triangle plot ', plot_num , ' over ', tot_plots
                   if (.not. Done2D(j2,j)) call Get2DPlotData(j2,j)
                end do
             end do
          end if
         
!------------------------------------------------------------------------------------
!                 DO 3D plots (.m file only, everything is in a single file already)
!------------------------------------------------------------------------------------
         !Do 3D plots (i.e. 2D scatter plots with coloured points)

         if (num_3D_plots /=0) then
            write (*,*) 'producing ',num_3D_plots, '3D scatter plots'
            filename = trim(outn)//trim(rootname)//'_3D.m'
            open(unit=50,file=filename,form='formatted',status='replace')
            call WriteMatLabInit(50, 3)
            write(50,'(A)') 'pts = load('''//trim(rootname)//'_single.txt'');'
             
            !write(50,'(A)') 'lab_fontsize = 24; axes_fontsize = 24; names_fontsize = 14;  textbox_fontsize = 30;  twolines_fontsize = 20; lwaxes = 2.0;'
            if (mod(num_3D_plots,2)==0 .and. num_3D_plots < 11) then
               plot_col = num_3D_plots/2
            else
               plot_col =  nint(sqrt(1.*num_3D_plots))
            end if
            plot_row = (num_3D_plots +plot_col-1)/plot_col 
            plot_num = 0
            do j=1, num_3D_plots
               read(plot_3D(j),*) ix1, ix2, ix3  !x, y, color
               if(all(colix(1:num_vars).ne.ix1+2) .or. all(colix(1:num_vars).ne.ix2+2) .or. all(colix(1:num_vars).ne.ix3+2)) cycle 
               do k = 1, num_vars
                  if(colix(k)-2 .eq. ix1) ix1 = k
                  if(colix(k)-2 .eq. ix2) ix2 = k 
                  if(colix(k)-2 .eq. ix3) ix3 = k 
               enddo 
               !
               if (ix3<1) ix3 = MostCorrelated2D(ix1,ix2,ix3)
               
               !passes on the filename for the output ps file
               dummystring =trim(IntToStr(j))
               fname = ExtractFileName(rootname)
               if (trim(plot_3D_psname) .eq. '') then
                  fname = trim(fname)//'_3D_'//trim(dummystring)//'.ps;'
               else
                  fname = trim(plot_3D_psname)//'_3D_'//trim(dummystring)//'.ps;'
               end if

               call  Write3DPlotMATLAB(50, ix1, ix2, ix3, fname)
               plot_num = plot_num + 1
            end do

            if(plot_num < num_3D_plots) then
             write(*,'(A,I4,A)') 'WARNING - you have requested', num_3D_plots, ' 3D plot(s) '
             write(*,'(A,I4,A)') '          but only', plot_num, ' have been produced'
             write(*,'(A)') &
             '          You might want to check your choice for plotparams. &
              & Notice that the parameters you want to plot in 3D have & 
              & to be included in plotparams'
            endif
            close(50)
         end if
         
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!                output of statistics
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

         write(*,*) 'writing margestats file... please wait'
         open(unit=50,file=trim(outn)//trim(rootname)//'.margestats',form='formatted',status='replace')
         write(50, '(A)') 'Marginalized 1D posterior pdf statistics ' 
         write(50, *) ' '
         write (50,'(A, F15.4,A, F15.4)') 'Average -ln(Like)   = ', meanchisq, '   or average chisq  = ', 2*meanchisq
         write (50,'(A, F15.4,A, F15.4)') '-ln(mean like)      = ', meanlike
         write (50,'(A, F15.4,A, F15.4)') 'Best fit -ln(like)  = ', maxlike,   '   or best fit chisq = ', 2*maxlike 
         write (50,'(A, F15.4)')         'Bayesian complexity = ', 2*(meanchisq - maxlike)
         if (NS_files) then
            open(unit=51,file=trim(infile)//'stats.dat',form='formatted',status='old', err=28)
            !read(51,*) InLine
            !write(*,*) InLine
            read(51, '(a)' ,err=600) junk(1)
            close(51)
            !write (50,'(A, F8.4, A, F8.4)')         '-ln(evidence)       = ', lnevidence, ' +/- ', lnev_error   
            write(50, *) trim(junk(1))
28          write (*,'(" file ",A," missing")') trim(infile)//'stats.dat'
         end if

         write(50, *) ' '
         write(lname(1), '(F5.2)') 100*contours(1) 
         write(lname(2), '(F5.2)') 100*contours(2)
         write(50,'(A)') ' parameter                      mean           sddev          lower '// &
         adjustl(lname(1))//'%   upper '//adjustl(lname(1))// &
        '%   lower '//adjustl(lname(2))//'%   upper '//adjustl(lname(2))//'%   tails'
         do j=1, num_vars
            pname = trim(lables(colix(j)))
            write(50,'(1I3" '//adjustl(pname)//'", 6E15.6,I4)') & 
            colix(j)-2, mean(j), sddev(j), &
            cont_lines(j,1:2,1),cont_lines(j,1:2,2),tails(colix(j))
         end do
         close(50)

         write(*,*) 'writing likestats file... please wait'         
         !Limits from global likelihood
         open(unit=50,file=trim(outn)//trim(rootname)//'.likestats',form='formatted',status='replace')
         write(50, '(A)') 'Global N-dimensional likelihood statistics ' 
         write(50, '(A)') 'Parameter values bounding the N-dim ' &
           //adjustl(lname(1))//'% and '//adjustl(lname(2))// &
           '%  posterior regions'
         write(50, *) ' ' 
         write (50,'(A, F15.4, A, F15.4)') &
          &  'Best fit sample -log(Like) = ', coldata(2,bestfit_ix), &
          &  ' or chi-square = ', 2.0*coldata(2,bestfit_ix)
         write (50,*) ' '
         write(50,'(A)') &
           ' parameter                      bestfit        lower ' &
           //adjustl(lname(1))//'%   upper '//adjustl(lname(1))// &
           '%   lower '//adjustl(lname(2))//'%   upper ' &
           //adjustl(lname(2))//'%   tails'
         do j=1, num_vars
            pname = trim(lables(colix(j)))            
            write(50,'(1I3" '//adjustl(pname)//'", 5E15.6,I4)') & 
                 colix(j)-2, coldata(j+2,bestfit_ix),&
                 minval(coldata(j+2,0:ND_cont1)), &
                 maxval(coldata(j+2,0:ND_cont1)), &
                 minval(coldata(j+2,0:ND_cont2)), &
                 maxval(coldata(j+2,0:ND_cont2)), tails(colix(j)) 
           
         end do
         close(50)

         write(*,*) 'writing proflstats file... please wait'
         open(unit=50,file=trim(outn)//trim(rootname)//'.proflstats',form='formatted',status='replace')
         write(50, '(A)') '1D profile likelihood statistics ' 
         write(50, '(A)') '1D intervals from likelihood ratio test' 
         do j=1, num_vars
            pname = trim(lables(colix(j)))
            write(50,'(1I3" '//adjustl(pname)//'")')  colix(j)-2
            do cc = 1, num_contours
               plname = ' '
               do ii = 1, int_num(j,cc)
                  write(numstr1, '(E12.5)')  profl_interval(j, 1, ii, cc)
                  write(numstr2,  '(E12.5)')  profl_interval(j, 2, ii, cc)               
                  plname = trim(plname)//' ['//trim(numstr1)//' , '//trim(numstr2)//']'
               end do
               write(50,'(A,A)')  '   Intervals at  '//adjustl(lname(cc))//'%: ', trim(plname) 
            end do
         end do
         close(50)


         stop

500      write(*,*) 'Read inline ', trim(InLine)
         stop 'error reading plotparams list in .ini file - does not match plotparams_num'
         
550      stop 'error reading logparams list in .ini file - does not match plotparams_num'

600      write (*,*) 'error reading evidence value file'
         stop         


       end program GetPlots

